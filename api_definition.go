/*
 * vela-api
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package vealapi

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// DefinitionApiService DefinitionApi service
type DefinitionApiService service

// DetailDefinitionOpts Optional parameters for the method 'DetailDefinition'
type DetailDefinitionOpts struct {
    Type_ optional.String
}

/*
DetailDefinition Detail a definition
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param definitionName identifier of the definition
 * @param optional nil or *DetailDefinitionOpts - Optional Parameters:
 * @param "Type_" (optional.String) -  query the definition type
@return V1SimpleResponse
*/
func (a *DefinitionApiService) DetailDefinition(ctx _context.Context, definitionName string, localVarOptionals *DetailDefinitionOpts) (V1SimpleResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1SimpleResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/definitions/{definitionName}"
	localVarPath = strings.Replace(localVarPath, "{"+"definitionName"+"}", _neturl.QueryEscape(parameterToString(definitionName, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// ListDefinitionsOpts Optional parameters for the method 'ListDefinitions'
type ListDefinitionsOpts struct {
    QueryAll optional.String
    AppliedWorkload optional.String
    OwnerAddon optional.String
    Scope optional.String
}

/*
ListDefinitions list all definitions
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param type_ query the definition type
 * @param optional nil or *ListDefinitionsOpts - Optional Parameters:
 * @param "QueryAll" (optional.String) -  query all definitions include hidden in UI
 * @param "AppliedWorkload" (optional.String) -  if specified, query the trait definition applied to the workload
 * @param "OwnerAddon" (optional.String) -  query by which addon created the definition
 * @param "Scope" (optional.String) -  query by the specified scope like WorkflowRun or Application
@return V1SimpleResponse
*/
func (a *DefinitionApiService) ListDefinitions(ctx _context.Context, type_ string, localVarOptionals *ListDefinitionsOpts) (V1SimpleResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1SimpleResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/definitions"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	localVarQueryParams.Add("type", parameterToString(type_, ""))
	if localVarOptionals != nil && localVarOptionals.QueryAll.IsSet() {
		localVarQueryParams.Add("queryAll", parameterToString(localVarOptionals.QueryAll.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AppliedWorkload.IsSet() {
		localVarQueryParams.Add("appliedWorkload", parameterToString(localVarOptionals.AppliedWorkload.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerAddon.IsSet() {
		localVarQueryParams.Add("ownerAddon", parameterToString(localVarOptionals.OwnerAddon.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Scope.IsSet() {
		localVarQueryParams.Add("scope", parameterToString(localVarOptionals.Scope.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// UpdateDefinitionStatusOpts Optional parameters for the method 'UpdateDefinitionStatus'
type UpdateDefinitionStatusOpts struct {
    V1UpdateDefinitionStatusRequest optional.Interface
}

/*
UpdateDefinitionStatus Update the status for a definition
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param definitionName
 * @param optional nil or *UpdateDefinitionStatusOpts - Optional Parameters:
 * @param "V1UpdateDefinitionStatusRequest" (optional.Interface of V1UpdateDefinitionStatusRequest) - 
@return V1SimpleResponse
*/
func (a *DefinitionApiService) UpdateDefinitionStatus(ctx _context.Context, definitionName string, localVarOptionals *UpdateDefinitionStatusOpts) (V1SimpleResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1SimpleResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/definitions/{definitionName}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"definitionName"+"}", _neturl.QueryEscape(parameterToString(definitionName, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.V1UpdateDefinitionStatusRequest.IsSet() {
		localVarOptionalV1UpdateDefinitionStatusRequest, localVarOptionalV1UpdateDefinitionStatusRequestok := localVarOptionals.V1UpdateDefinitionStatusRequest.Value().(V1UpdateDefinitionStatusRequest)
		if !localVarOptionalV1UpdateDefinitionStatusRequestok {
			return localVarReturnValue, nil, reportError("v1UpdateDefinitionStatusRequest should be V1UpdateDefinitionStatusRequest")
		}
		localVarPostBody = &localVarOptionalV1UpdateDefinitionStatusRequest
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// UpdateUISchemaOpts Optional parameters for the method 'UpdateUISchema'
type UpdateUISchemaOpts struct {
    V1UpdateUiSchemaRequest optional.Interface
}

/*
UpdateUISchema Update the UI schema for a definition
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param definitionName
 * @param optional nil or *UpdateUISchemaOpts - Optional Parameters:
 * @param "V1UpdateUiSchemaRequest" (optional.Interface of V1UpdateUiSchemaRequest) - 
@return V1SimpleResponse
*/
func (a *DefinitionApiService) UpdateUISchema(ctx _context.Context, definitionName string, localVarOptionals *UpdateUISchemaOpts) (V1SimpleResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  V1SimpleResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/v1/definitions/{definitionName}/uischema"
	localVarPath = strings.Replace(localVarPath, "{"+"definitionName"+"}", _neturl.QueryEscape(parameterToString(definitionName, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.V1UpdateUiSchemaRequest.IsSet() {
		localVarOptionalV1UpdateUiSchemaRequest, localVarOptionalV1UpdateUiSchemaRequestok := localVarOptionals.V1UpdateUiSchemaRequest.Value().(V1UpdateUiSchemaRequest)
		if !localVarOptionalV1UpdateUiSchemaRequestok {
			return localVarReturnValue, nil, reportError("v1UpdateUiSchemaRequest should be V1UpdateUiSchemaRequest")
		}
		localVarPostBody = &localVarOptionalV1UpdateUiSchemaRequest
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
